// ================================================================================
// ==      This file is a part of Turbo Badger. (C) 2011-2014, Emil Seger√•s      ==
// ==                     See tb_core.h for more information.                    ==
// ================================================================================

#include "tb_font_renderer.h"
#include "tb_renderer.h"
#include "tb_system.h"
#include <vector>
#include <glm/vec2.hpp>
using glm::vec2;

#ifdef TB_FONT_RENDERER_FREETYPEX

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_SIZES_H
#include FT_STROKER_H

int num_fonts = 0;
bool ft_initialized = false;
static FT_Library g_freetype = nullptr;

using namespace tb;

/** Cache of truetype file data, so it isn't loaded multiple times for each font size */

class FreetypeFace;
static TBHashTableOf<FreetypeFace> ft_face_cache;

class FreetypeFace
{
public:
	FreetypeFace() : hashID(0), f_face(0), refCount(1), outline(false) { }
	~FreetypeFace()
	{
		if (hashID)
			ft_face_cache.Remove(hashID);
		FT_Done_Face(f_face);
	}
	void Release()
	{
		--refCount;
		if (!refCount)
			delete this;
	}

	uint32_t hashID;
	TBTempBuffer ttf_buffer;
	FT_Face f_face;
	unsigned int refCount;
	bool outline;
};


/** FreetypeFontRenderer renders fonts using the freetype library. */
class FreetypeFontRenderer : public TBFontRenderer
{
public:
	FreetypeFontRenderer();
	~FreetypeFontRenderer();

	virtual TBFontFace *Create(TBFontManager *font_manager, const char *filename,
								const TBFontDescription &font_desc);

	virtual TBFontMetrics GetMetrics();
	virtual bool RenderGlyph(TBFontGlyphData *dst_bitmap, UCS4 cp, const TBColor &color);
	virtual void GetGlyphMetrics(TBGlyphMetrics *metrics, UCS4 cp);
private:
	bool Load(FreetypeFace *face, const TBFontDescription &font_desc);
	bool Load(const char *filename, const TBFontDescription &font_desc);

	FT_Size m_size;
	FreetypeFace *m_face;
	TBColor m_data[512]; // 32x32
	static const int maxcw = 32;
};

FreetypeFontRenderer::FreetypeFontRenderer()
	: m_size(nullptr)
	, m_face(nullptr)
{
	num_fonts++;
}

FreetypeFontRenderer::~FreetypeFontRenderer()
{
	FT_Done_Size(m_size);
	if (m_face)
		m_face->Release();

	num_fonts--;
	if (num_fonts == 0 && ft_initialized)
	{
		FT_Done_FreeType(g_freetype);
		ft_initialized = false;
	}
}

struct Rect {
	Rect() { }
	Rect(float left, float top, float right, float bottom)
		: xmin(left), xmax(right), ymin(top), ymax(bottom) { }

	void Include(const vec2 &r) {
		xmin = Min(xmin, r.x);
		ymin = Min(ymin, r.y);
		xmax = Max(xmax, r.x);
		ymax = Max(ymax, r.y);
	}

	float Width() const { return xmax - xmin + 1; }
	float Height() const { return ymax - ymin + 1; }

	float xmin, xmax, ymin, ymax;
};

// A horizontal pixel span generated by the FreeType renderer.
struct Span {
	Span() { }
	Span(int _x, int _y, int _width, int _coverage)
		: x(_x), y(_y), width(_width), coverage(_coverage) { }
	int x, y, width, coverage;
};
typedef std::vector<Span> Spans;

// Each time the renderer calls us back we just push another span entry on
// our list.
static void
RasterCallback(const int y,
               const int count,
               const FT_Span * const spans,
               void * const user) 
{
	Spans *sptr = (Spans *)user;
	for (int i = 0; i < count; ++i) 
		sptr->push_back(Span(spans[i].x, y, spans[i].len, spans[i].coverage));
}

// Set up the raster parameters and render the outline.
static void
RenderSpans(FT_Library &library,
            FT_Outline * const outline,
            Spans *spans) 
{
	FT_Raster_Params params;
	memset(&params, 0, sizeof(params));
	params.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
	params.gray_spans = RasterCallback;
	params.user = spans;
	FT_Outline_Render(library, outline, &params);
}

TBFontMetrics FreetypeFontRenderer::GetMetrics()
{
	TBFontMetrics metrics;
	metrics.ascent = (int16_t) (m_size->metrics.ascender >> 6);
	metrics.descent = (int16_t) -(m_size->metrics.descender >> 6);
	metrics.height = (int16_t) (m_size->metrics.height >> 6);
	return metrics;
}
#define FTC(CALL) do {													\
		FT_Error err = CALL;											\
		if (err) TBDebugPrint("Error %s:%d = %d\n", __FILE__, __LINE__, err); \
		/*else TBDebugPrint("OK %s:%d\n", __FILE__, __LINE__); */		\
	} while(0)

bool FreetypeFontRenderer::RenderGlyph(TBFontGlyphData *data, UCS4 cp, const TBColor & fontCol)
{
	FT_Activate_Size(m_size);
	if (m_face->outline) {
		FT_Face face = m_face->f_face;
		FT_UInt gindex = FT_Get_Char_Index(face, cp);
		FTC(FT_Load_Glyph(face, gindex, FT_LOAD_NO_BITMAP));
		// Need an outline for this to work.
		assert(face->glyph->format == FT_GLYPH_FORMAT_OUTLINE);
		//float bearingX = face->glyph->metrics.horiBearingX >> 6;
		float advance = face->glyph->advance.x >> 6;

        // Render the basic glyph to a span list.
        Spans spans;
        RenderSpans(g_freetype, &face->glyph->outline, &spans);

        // Next we need the spans for the outline.
        Spans outlineSpans;
		float outlineWidth = 0.3;
		//TBColor fontCol = TBColor(255,255,255,255);
		TBColor outlineCol(255-fontCol.r, 255-fontCol.g, 255-fontCol.b);

        // Set up a stroker.
        FT_Stroker stroker;
        FT_Stroker_New(g_freetype, &stroker);
        FT_Stroker_Set(stroker,
                       (int)(outlineWidth * 64),
                       FT_STROKER_LINECAP_ROUND,
                       FT_STROKER_LINEJOIN_ROUND,
                       0);

        FT_Glyph glyph;
        FTC(FT_Get_Glyph(face->glyph, &glyph));
		FT_Glyph_StrokeBorder(&glyph, stroker, 0, 1);
		// Again, this needs to be an outline to work.
		if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
		{
			// Render the outline spans to the span list
			FT_Outline *o = &reinterpret_cast<FT_OutlineGlyph>(glyph)->outline;
			RenderSpans(g_freetype, o, &outlineSpans);
		}

		// Clean up afterwards.
		FT_Stroker_Done(stroker);

		// Now we need to put it all together.
		if (!spans.empty()) {
			// Figure out what the bounding rect is for both the span lists.
			Rect rect(spans.front().x,
					  spans.front().y,
					  spans.front().x,
					  spans.front().y);
			for (Spans::iterator s = spans.begin(); s != spans.end(); ++s) {
				rect.Include(vec2(s->x, s->y));
				rect.Include(vec2(s->x + s->width - 1, s->y));
			}
			for (Spans::iterator s = outlineSpans.begin(); s != outlineSpans.end(); ++s) {
				rect.Include(vec2(s->x, s->y));
				rect.Include(vec2(s->x + s->width - 1, s->y));
			}

#if 0
			// This is unused in this test but you would need this to draw
			// more than one glyph.
			float bearingX = face->glyph->metrics.horiBearingX >> 6;
			float bearingY = face->glyph->metrics.horiBearingY >> 6;
			float advance = face->glyph->advance.x >> 6;
#endif

			// Get some metrics of our image.
			int imgWidth = rect.Width(),
				imgHeight = rect.Height(),
				imgSize = imgWidth * imgHeight;

			// Allocate data for our image and clear it out to transparent.
			memset(&m_data[0], 0, sizeof(TBColor) * imgSize);

			// Loop over the outline spans and just draw them into the
			// image.
			for (auto & s : outlineSpans)
				for (int w = 0; w < s.width; ++w)
					m_data[(int)((imgHeight - 1 - (s.y - rect.ymin)) * imgWidth
								 + s.x - rect.xmin + w)] =
						TBColor(outlineCol.r, outlineCol.g, outlineCol.b, s.coverage);

			// Then loop over the regular glyph spans and blend them into
			// the image.
			for (auto & s : spans)
				for (int w = 0; w < s.width; ++w) {
					TBColor & dst =
						m_data[(int)((imgHeight - 1 - (s.y - rect.ymin)) * imgWidth + s.x - rect.xmin + w)];
					TBColor src(fontCol.r, fontCol.g, fontCol.b, s.coverage);
					dst.r = (int)(dst.r + ((src.r - (int)dst.r) * src.a) / 255.0f);
					dst.g = (int)(dst.g + ((src.g - (int)dst.g) * src.a) / 255.0f);
					dst.b = (int)(dst.b + ((src.b - (int)dst.b) * src.a) / 255.0f);
					dst.a = Min(255, dst.a + (int)src.a);
				}
			//TBDebugPrint("%d %d stride:%d\n", slot->bitmap.width, slot->bitmap.rows, slot->bitmap.pitch);
			data->w = imgWidth;
			data->h = imgHeight;
			data->stride = imgWidth;
			data->rgb = true;
			data->data32 = (unsigned int *)&m_data[0];
		}
		else {
			// usually the space char :p
			data->w = advance;
			data->h = 0;
			data->stride = 0;
			data->rgb = false;
			data->data32 = (unsigned int *)&m_data[0];
		}

		// done
		FT_Done_Glyph(glyph);
		return true;
	}
	else {
		FT_GlyphSlot slot = m_face->f_face->glyph;
		if (FT_Load_Char(m_face->f_face, cp, FT_LOAD_RENDER) ||
			slot->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY)
			return false;
		data->w = slot->bitmap.width;
		data->h = slot->bitmap.rows;
		data->stride = slot->bitmap.pitch;
		data->data8 = slot->bitmap.buffer;
		return data->data8 ? true : false;
	}
}

void FreetypeFontRenderer::GetGlyphMetrics(TBGlyphMetrics *metrics, UCS4 cp)
{
	FT_Activate_Size(m_size);
	FT_GlyphSlot slot = m_face->f_face->glyph;
	if (FT_Load_Char(m_face->f_face, cp, FT_LOAD_RENDER))
		return;
	metrics->advance = (int16_t) (slot->advance.x >> 6);
	metrics->x = slot->bitmap_left;
	metrics->y = - slot->bitmap_top;
}

bool FreetypeFontRenderer::Load(FreetypeFace *face, const TBFontDescription &font_desc)
{
	int size = font_desc.GetSize();
	// Should not be possible to have a face if freetype is not initialized
	assert(ft_initialized);
	m_face = face;
	m_face->outline = 1; //font_desc.GetOutline();
	if (FT_New_Size(m_face->f_face, &m_size) ||
		FT_Activate_Size(m_size) ||
		FT_Set_Pixel_Sizes(m_face->f_face, 0, size))
		return false;
	return true;
}

bool FreetypeFontRenderer::Load(const char *filename, const TBFontDescription &font_desc)
{
	if (!ft_initialized)
		ft_initialized = !FT_Init_FreeType(&g_freetype);
	if (!ft_initialized)
		return false;

	m_face = new FreetypeFace();
	if (!m_face)
		return false;

	if (!m_face->ttf_buffer.AppendFile(filename))
		return false;

	unsigned char *ttf_ptr = (unsigned char *) m_face->ttf_buffer.GetData();
	if (FT_New_Memory_Face(g_freetype, ttf_ptr, m_face->ttf_buffer.GetAppendPos(), 0, &m_face->f_face))
		return false;
	return Load(m_face, font_desc);
}

TBFontFace *FreetypeFontRenderer::Create(TBFontManager *font_manager, const char *filename, const TBFontDescription &font_desc)
{
	if (FreetypeFontRenderer *fr = new FreetypeFontRenderer())
	{
		TBID face_cache_id(filename);
		FreetypeFace *f = ft_face_cache.Get(face_cache_id);
		if (f)
		{
			++f->refCount;
			if (fr->Load(f, font_desc))
				if (TBFontFace *font = new TBFontFace(font_manager->GetGlyphCache(), fr, font_desc))
					return font;
		}
		else if (fr->Load(filename, font_desc))
		{
			if (ft_face_cache.Add(face_cache_id, fr->m_face))
				fr->m_face->hashID = face_cache_id;
			if (TBFontFace *font = new TBFontFace(font_manager->GetGlyphCache(), fr, font_desc))
				return font;
		}

		delete fr;
	}
	return nullptr;
}

void register_freetype_font_renderer()
{
	if (FreetypeFontRenderer *fr = new FreetypeFontRenderer)
		g_font_manager->AddRenderer(fr);
}

#endif // TB_FONT_RENDERER_FREETYPEX
